## Minitalk

Minitalk is a project that make use of signals to transmit messages. The communication goes from client to the server. 
Client takes PID of server and message to be sent. Server recieves this message and prints it out.

It's similar to Morse code, just instead of using dot and dashes, i. e., short and long signals, UNIX signals are used. In UNIX there are two configurable signals: SIGUSR1 and SIGUSR2. In the code I treated them as 0 and 1 respectively. 

**Signals**

Signals are notifications to a process about an important event. Each signal is identified by a unique integer value and has a specific meaning and purpose. Common signals include SIGINT (interrupt), which is generated by pressing Ctrl+C on the keyboard, and SIGTERM (terminate), which is often used for graceful process termination. 
Each signal (except for KILL and STOP) can be set to be handled in a user defined way. To define the way the signals are handled we use function _signal_ (not recommended due to compatibility) or _sigaction_.

In the project I make user defined signals _SIGUSR1_ and _SIGUSR2_ to be handled with _signal_handler_ function. 
```C
struct sigaction	sa;

	sigemptyset (&sa.sa_mask);
	sa.sa_handler = &signal_handler;
	sigaction(SIGUSR1, &sa, NULL);
```

**Client** first decompose the each character string to its binary representation by bit shifting and then sends it out. 
```C
if ((num >> i) & 1)
  kill(pid, SIGUSR2);
```

**Server** receives the signal and composes the binary representation of the character out of it by yet another binary shift and or operation.

```C
if (signum == SIGUSR1)
{
  c = c << 1;
  i++;
}
else if (signum == SIGUSR2)
{
  c = ((c << 1) | 1);
  i++;
}
```
Important part is not to get the server jumbled by incoming traffic. For this reasong there is a set ```usleep``` value for client. This prevents clogging the server as well as ensuring smooth communication.
